import pandas as pd
import matplotlib.pyplot as plt
import numpy as np # Import numpy for calculations
import os # Import os to check for file existence

# Define the filename for the CSV results (updated for averaged data)
csv_filename = 'saxpy_timing_results_avg.csv'

# --- Check if the CSV file exists ---
if not os.path.exists(csv_filename):
    print(f"Error: The file '{csv_filename}' was not found.")
    print("Please make sure the CSV file is in the same directory as this script,")
    print("and that the latest C code (with averaging) has been compiled and run to generate it.")
    # Exit the script if the file doesn't exist
    exit()

# --- Read the CSV data using pandas ---
try:
    # Read the CSV file into a pandas DataFrame.
    # Assumes the first row is the header matching the averaged C code output.
    df_full = pd.read_csv(csv_filename) # Read the full data first
    # Ensure log2_n column is integer type
    df_full['Vector Size (log2 N)'] = df_full['Vector Size (log2 N)'].astype(int)

    # --- Filter the DataFrame for the desired range (p=15 to p=25) ---
    min_p = 10
    max_p = 20
    df = df_full[(df_full['Vector Size (log2 N)'] >= min_p) & (df_full['Vector Size (log2 N)'] <= max_p)].copy()
    # Check if the filtered dataframe is empty
    if df.empty:
        print(f"Error: No data found in the range log2 N = {min_p} to {max_p} in '{csv_filename}'.")
        exit()
    # -----------------------------------------------------------------

except FileNotFoundError:
    print(f"Error: Could not find the file '{csv_filename}'.")
    exit()
except pd.errors.EmptyDataError:
    print(f"Error: The file '{csv_filename}' is empty.")
    exit()
except KeyError as e:
    print(f"Error: Missing expected column in CSV: {e}")
    print("Please ensure the CSV file was generated by the latest C code version")
    print("and uses the 'Avg ...' column names.")
    exit()
except Exception as e:
    print(f"An error occurred while reading the CSV file: {e}")
    exit()

# --- Extract data columns and Calculate Overhead (from filtered data) ---
try:
    # Get the 'Vector Size (log2 N)' column for the x-axis (from filtered df).
    log2_n = df['Vector Size (log2 N)']
    # Get the measured time components using the "Avg" names
    kernel_time = df['Avg Kernel Time (ms)']
    host_alloc_time = df['Avg Host Alloc Time (ms)']
    device_alloc_time = df['Avg Device Alloc Time (ms)']
    host_init_time = df['Avg Host Init Time (ms)']
    h2d_time = df['Avg H2D Time (ms)']
    d2h_time = df['Avg D2H Time (ms)']
    # cleanup_time_avg = df['Avg Cleanup Time (ms)'] # Read if needed, but not plotted

    # Get the total measured time.
    total_time = df['Avg Total Time (ms)']

    # Calculate the sum of the individually measured components *that we will plot*
    # (Excluding cleanup time as requested for the plot)
    sum_of_plotted_parts = (host_alloc_time + device_alloc_time + host_init_time +
                            h2d_time + kernel_time + d2h_time)

    # Calculate the overhead time (remaining difference from total).
    # This overhead now implicitly includes the average cleanup time measured by C code.
    overhead_time = np.maximum(0, total_time - sum_of_plotted_parts) # Using 0 instead of epsilon for linear scale

    # --- Define components for stacking in the desired order ---
    # (Excluding Cleanup from the plot)
    components = {
        'Overhead': overhead_time,      # Bottom (Includes cleanup + other)
        'Device Alloc': device_alloc_time,
        'Host Alloc': host_alloc_time,
        'Kernel': kernel_time,
        'Host Init': host_init_time,
        'D2H Transfer': d2h_time,
        'H2D Transfer': h2d_time,       # Top
    }
    # Create labels for the legend
    component_labels = [f'{label} (ms)' for label in components.keys()]

except KeyError as e:
    # Handle missing columns specifically after trying to access them
    # Update expected columns to use "Avg" prefix
    expected_cols = ['Vector Size (log2 N)', 'Avg Kernel Time (ms)', 'Avg Host Alloc Time (ms)',
                     'Avg Device Alloc Time (ms)', 'Avg Host Init Time (ms)', 'Avg H2D Time (ms)',
                     'Avg D2H Time (ms)', 'Avg Total Time (ms)'] # Removed Avg Cleanup Time (ms)
    col_name = str(e).strip("'")
    # Ignore error only if it's about the cleanup column which we don't strictly need here
    if col_name not in expected_cols and col_name != 'Avg Cleanup Time (ms)':
         print(f"Error: Missing essential column in CSV: {e}")
         print("Please ensure the CSV file was generated by the latest C code version")
         print("and uses the 'Avg ...' column names.")
         exit()


# --- Create the Stacked Bar Plot ---
plt.figure(figsize=(14, 8)) # Adjust figure size

# Initialize the bottom of the bars for stacking (using filtered data length)
bottom = np.zeros(len(log2_n))

# --- Use the 'Paired' colormap ---
# Adjust number of colors needed
colors = plt.cm.get_cmap('Paired', len(components))

# Iterate through the reordered components and plot them as stacked bars
for i, (label, data) in enumerate(components.items()):
    # Use a different color for each component from the 'Paired' map
    plt.bar(log2_n, data, bottom=bottom, label=component_labels[i], color=colors(i))
    # Update the bottom for the next component
    bottom += data # Add the actual data value

# --- Add plot labels and title ---
plt.xlabel('Vector Size (log2 N)') # Label for the x-axis
# Ensure linear y-axis (default, but explicit if needed: plt.yscale('linear'))
plt.ylabel('Time (milliseconds)')   # Label for the y-axis

plt.title('SAXPY Avg Execution Time Breakdown vs. Vector Size (log2 N = 10-20)') # Updated Title

# --- Set Integer X-axis Ticks ---
# Determine the range of log2_n values from the *filtered* data
min_log2_n = log2_n.min()
max_log2_n = log2_n.max()
# Create ticks every 1 unit for the 15-25 range for clarity
step = 1
x_ticks = np.arange(min_log2_n, max_log2_n + 1, step)
plt.xticks(x_ticks) # Set the calculated integer ticks

plt.grid(True, axis='y', linestyle='--', linewidth=0.5) # Add horizontal grid lines
# Place legend outside the plot area to avoid overlap
plt.legend(title="Time Components", loc='upper left', bbox_to_anchor=(1.02, 1), borderaxespad=0.)

# --- Display the plot ---
# Adjust layout to prevent labels overlapping, especially the legend
plt.tight_layout(rect=[0, 0, 0.80, 1]) # Adjust rect to make space for legend
# Show the plot window.
plt.show()

print(f"Filtered (log2 N = 15-25) stacked bar chart generated from '{csv_filename}'.")

